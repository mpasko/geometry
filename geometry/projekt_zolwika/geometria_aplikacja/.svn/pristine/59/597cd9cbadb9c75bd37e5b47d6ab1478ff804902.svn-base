package view;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Shape;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Point2D.Double;
import java.awt.geom.Rectangle2D;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.swing.JComponent;
import javax.swing.SwingUtilities;

import model.Model;
import model.PointModel;
import formatter.IFormatter;

class ShapeWrap
{
	public Shape 	shape;
	public String	label;
	public Color	color;
	
	ShapeWrap()
	{
		shape = null;
		label = "";
		color = Color.BLACK;
	}
	
	void Draw(Graphics2D g2)
	{
        g2.setPaint(color);
        g2.fill(shape);
	}
	
	boolean Collision(Point2D p)
	{
		return shape.contains(p);
	}
	
	static final double THRESHHOLD = 2.f;
	
	static Rectangle2D GenerateRectFromPoint(Point2D p, double thr)
	{
		return new Rectangle2D.Double(p.getX() - thr/2, p.getY() - thr/2, 
				thr, thr);
	}
	
	ShapeWrap(Shape s)
	{
		shape = s;
		label = "";
		color = Color.BLACK;
	}
}

class LineWrap extends ShapeWrap
{
	LineWrap(Shape s)
	{
		super(s);
	}
	
	LineWrap(Point2D.Double p0, Point2D.Double p1)
	{
		super();
		shape = new Line2D.Double(p0, p1);
	}
	LineWrap(double x0, double y0, double x1, double y1)
	{
		super();
		shape = new Line2D.Double(x0, y0, x1, y1);
	}
	
	void Draw(Graphics2D g2)
	{
        g2.setPaint(color);
        g2.draw(shape);
	}
	
	boolean Collision(Point2D p)
	{
		return shape.intersects(GenerateRectFromPoint(p, THRESHHOLD));
	}
}

public class PlanePanel extends JComponent implements MouseMotionListener, MouseListener, MouseWheelListener, IController {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1379314306499920242L;
	
	private double magnif = 1.0F;
	private double transX = 0., transY = 0.;
	private int labelGenerator;  
	
	AffineTransform transformation;
	private int pressX, pressY;
	boolean pressed = false;
	
	ArrayList<ShapeWrap> 		shapes;
	Mode 						workingMode;
	
	boolean 					changeMade;
	ArrayList<Point2D.Double>	editedPoints;
	Shape 						editedShape;
	int editedShapeID = 0;

	private Model _all_points;
	
	private Object selection=null;

	private Color currentColor = Color.BLACK;

	private IFormatter formatter;
	
	enum Mode { VIEW, CREATE };
	
	public PlanePanel()
	{
		addMouseListener(this);
		addMouseMotionListener(this);
		addMouseWheelListener(this);
		shapes = new ArrayList<ShapeWrap>();
		shapes.ensureCapacity(1000);
		
		workingMode = Mode.VIEW;
		
		editedShape = null;
		editedPoints = new ArrayList<Point2D.Double>();
		changeMade = false;
		
		_all_points = new Model();
		transformation = new AffineTransform();
		ResetView();
	}
	
	static Shape GenerateShapeFromPoints(List<Point2D.Double> points)
	{
		if(points.size() == 0) return null;
		if(points.size() <= 2)
		{
			Line2D.Double line = new Line2D.Double();
			line.x1 = points.get(0).x;
			line.y1 = points.get(0).y;
			
			line.x2 = points.get(points.size()-1).x;
			line.y2 = points.get(points.size()-1).y;
			
			return line;
		}
		else
		{
			GeneralPath path = null;
			for(Point2D.Double p : points)
			{
				if(path == null)
				{
					path = new GeneralPath();
					path.moveTo(p.getX(), p.getY());
				}
				else
				{
					path.lineTo(p.getX(), p.getY());
				}
			}
			return path;
		}
	}
	
	public List<Point2D.Double> getPoints(){
		LinkedList<Point2D.Double> ret = new LinkedList<Point2D.Double>();
		for(PointModel model : _all_points.points){
			ret.add(model.point);
		}
		return ret;
	}

	@Override
    public void paintComponent(Graphics g) {
		super.paintComponent(g);

        Graphics2D g2d = (Graphics2D) g;
        
        for(PointModel point : _all_points.points){
        	point.Draw(g2d,magnif,transX,transY,this.getWidth()/2, this.getHeight()/2);
        }
        
        AffineTransform savedTransform = g2d.getTransform();

        AffineTransform translation = new AffineTransform();
        translation.translate(this.getWidth()/2, this.getHeight()/2);
        translation.concatenate(AffineTransform.getScaleInstance(magnif, magnif));
        translation.translate(transX,transY);
        transformation = translation;
        g2d.transform(transformation);
        
        for(ShapeWrap sw : shapes)
        {
        	sw.Draw(g2d);
        }
        
        if(workingMode == Mode.CREATE)
        {
	        if(changeMade)
	        	editedShape = GenerateShapeFromPoints(editedPoints);
	        if(editedShape != null)
	        	g2d.draw(editedShape);
        }
        
        g2d.transform(savedTransform);
    }

	@Override
	public void mouseMoved(MouseEvent e) {
	}
	
	Object HandleCollisions(MouseEvent e)
	{
		for(ShapeWrap sw : shapes)
		{
			if(sw.Collision(GetTransformed(e.getPoint())))
			{
				System.out.print("clicked ");
				if(sw.label.equals(""))
					System.out.println("unknown label");
				else
					System.out.println(sw.label);
				
				return sw;
			}
		}
		for(PointModel pm :_all_points.points){
			
			if (Math.abs(pm.getVisibleX(magnif, transX, this.getWidth()/2) - e.getPoint().x) <= PointModel.pointW){
				if (Math.abs(pm.getVisibleY(magnif, transY, this.getHeight()/2) - e.getPoint().y) <= PointModel.pointW){
					System.out.println("clicked "+pm.label);
					return pm;
				}
			}
		}
		
		return null;
	}
	
	void AddPointToEditedList(Point2D p)
	{
		editedPoints.add(new Point2D.Double((double)p.getX(), (double)p.getY()));
		changeMade = true;
		_all_points.points.add(new PointModel(p, this.currentColor, 
				new Integer(this.labelGenerator++).toString(),
				this.editedShapeID
				));
		repaint();
	}
	
	void RemoveLastPointFromList()
	{
		if(editedPoints.isEmpty()) return;
		editedPoints.remove(editedPoints.size()-1);
		changeMade = true;
		repaint();
	}
	
	public void CloseEditedShape()
	{
		Shape s = GenerateShapeFromPoints(editedPoints);
		editedPoints = new ArrayList<Point2D.Double>();
		
		if(s instanceof Line2D.Double)
		{
			LineWrap lw = new LineWrap(s);
			lw.color = this.currentColor;
			shapes.add(lw);
		}
		else if(s instanceof GeneralPath)
		{
			((GeneralPath)s).closePath();
			ShapeWrap sw = new ShapeWrap(s);
			sw.color = this.currentColor;
			shapes.add(sw);
		}
		
		this.editedShapeID++;
		repaint();
	}
	
	Point2D GetTransformed(Point mouseClick)
	{
		Point2D.Double coords = new Point2D.Double(mouseClick.x, mouseClick.y);
		try {
			return transformation.createInverse().transform(coords, null);
		} catch (NoninvertibleTransformException e) {
			e.printStackTrace();
		}
		return coords;
	}
	
	@Override
	public void mouseClicked(MouseEvent e) {
		if(workingMode == Mode.CREATE)
		{
			if(SwingUtilities.isLeftMouseButton(e))
				AddPointToEditedList(GetTransformed(e.getPoint()));
			else if(SwingUtilities.isRightMouseButton(e) && e.isAltDown())
			{
				RemoveLastPointFromList();
			}
			else if(SwingUtilities.isRightMouseButton(e))
			{
				CloseEditedShape();
				workingMode = Mode.VIEW;
			}				
		}
		else if(workingMode == Mode.VIEW)
		{
			if(HandleCollisions(e) != null)
			{
				
			}
		}
	}

	@Override
	public void mousePressed(MouseEvent e) {
		Object collider = HandleCollisions(e);
		if(SwingUtilities.isLeftMouseButton(e))
		{
			pressX = e.getPoint().x;
			pressY = e.getPoint().y;
			pressed = true;
		}
		this.selection = collider;
	}
	
	@Override
	public void mouseDragged(MouseEvent e) {
		movement(e);
		if(pressed)
        {
			pressX = e.getPoint().x;
			pressY = e.getPoint().y;
        }
	}
	
	private void movement(MouseEvent e){
		double dx = (double)(e.getPoint().x - pressX)/magnif;
		double dy = (double)(e.getPoint().y - pressY)/magnif;
		if(pressed && (selection == null)){
			transX += dx;
			transY += dy;
		}else if(selection!=null){
			if(selection instanceof PointModel){
				PointModel moved = (PointModel) selection;
				moved.point.x += dx;
				moved.point.y += dy;
				regenerateShapes();
			}else if(selection instanceof ShapeWrap){
				ShapeWrap moved = (ShapeWrap) selection;
				int num = this.shapes.indexOf(moved);
				for(PointModel pm : _all_points.points){
					if(pm.shape==num){
						pm.point.x += dx;
						pm.point.y += dy;
					}
				}
				regenerateShapes();
			}
		}
		repaint();
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		movement(e);
		pressed = false;
		selection = null;
	}

	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void SetColor(Color c) {
		this.currentColor = c;
	}

	@Override
	public void Save(String filename) {
		try {
			formatter.saveAll(new PrintStream(new File(filename)), _all_points);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}
	
	private void regenerateShapes(){
		int num = -1;
		if(selection!= null && selection instanceof ShapeWrap){
			num = this.shapes.indexOf(selection);
		}
		
		//latanie dziury - potrzebna refaktoryzacja
		
		Map<Integer,List<PointModel>> map  = new HashMap<Integer, List<PointModel>>();
		this.shapes.clear();
		for(PointModel p : _all_points.points){
			List<PointModel> shape = map.get(p.shape);
			if(shape == null){
				shape = new ArrayList<PointModel>();
				map.put(p.shape, shape);
			}
			shape.add(p);
		}
		for(List<PointModel> shape:map.values()){
			List<Double> points = new ArrayList<Double>();
			for(PointModel pm:shape){
				points.add(pm.point);
			}
			ShapeWrap sh = new ShapeWrap(GenerateShapeFromPoints(points));
			sh.color = shape.get(0).color;
			this.shapes.add(sh);
		}
		if(num > -1){
			selection = shapes.get(num);
		}
		this.repaint();
	}

	@Override
	public void Load(String filename) {
		try {
			_all_points = formatter.loadAll(new FileInputStream(filename));
			regenerateShapes();
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void SetFormatter(IFormatter formatter) {
		this.formatter = formatter;
	}

	@Override
	public void mouseWheelMoved(MouseWheelEvent e) {
		if(SwingUtilities.isLeftMouseButton(e))
		{
			magnif = magnif * (1.f + e.getWheelRotation() * 0.2);
		}
		repaint();
	}

	@Override
	public void ResetView() {
//		transX = this.getWidth()/2;
//		transY = this.getHeight()/2;
		transX = 0.0;
		transY = 0.0;
		magnif = 1.f;
		repaint();
	}

	@Override
	public void AddPoint() {
		// TODO Auto-generated method stub
		if(workingMode == Mode.VIEW)
			workingMode = Mode.CREATE;
	}

	@Override
	public void SetZoom(int value) {
		magnif = Math.exp((double)(value)/8);
		repaint();
	}

	@Override
	public void Refresh(Model m) {
		final Model mod = m;
		SwingUtilities.invokeLater(new Runnable() {
            public void run() {
            	PlanePanel.this._all_points = mod;
            	regenerateShapes();
            	repaint();
            }
		});
	}

	@Override
	public Model GetModel() {
		return this._all_points;
	}
}
